Ø±Ø¨Ø§Øª Ù…Ø¯ÛŒØ±ÛŒØª Ú¯Ø±ÙˆÙ‡ ØªÙ„Ú¯Ø±Ø§Ù… Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª ØªØ±Ø¬Ù…Ù‡ØŒ Ø¢Ù…Ø§Ø±ØŒ Ø®ÙˆØ´â€ŒØ¢Ù…Ø¯Ú¯ÙˆÛŒÛŒ ØªØµÙˆÛŒØ±ÛŒ Ùˆ Ø¯Ø§Ù†Ù„ÙˆØ¯Ø±

import os import yt_dlp import logging import datetime import translators as ts from telegram import Update, ChatMember, ChatAction, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, MessageEntity from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext from collections import defaultdict from apscheduler.schedulers.background import BackgroundScheduler

ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù„Ø§Ú¯

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO) logger = logging.getLogger(name)

Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ù…ÙˆÙ‚ØªÛŒ Ø¢Ù…Ø§Ø±

message_count = defaultdict(int) user_data = defaultdict(lambda: {'count': 0, 'hours': set()})

Ù„ÛŒØ³Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ

silent_list = set() ban_list = set() special_users = set() custom_welcome = {'photo': None, 'text': 'Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒ!'}

ØªØ±Ø¬Ù…Ù‡ Ù¾ÛŒØ§Ù… Ø±ÛŒÙ¾Ù„Ø§ÛŒâ€ŒØ´Ø¯Ù‡

langs = ['en', 'ar', 'hi'] def translate_reply(update: Update, context: CallbackContext): try: if update.message.reply_to_message: original_text = update.message.reply_to_message.text translated = ts.translate_text(original_text, to_language='fa') update.message.reply_text(f"ØªØ±Ø¬Ù…Ù‡: {translated}") else: update.message.reply_text("âš ï¸ Ù„Ø·ÙØ§Ù‹ Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± Ø±Ø§ Ø±ÙˆÛŒ ÛŒÚ© Ù¾ÛŒØ§Ù… Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.") except Exception as e: update.message.reply_text("âš ï¸ Ø®Ø·Ø§ Ø¯Ø± ØªØ±Ø¬Ù…Ù‡. Ù„Ø·ÙØ§Ù‹ Ø¨Ø¹Ø¯Ø§Ù‹ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.")

Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø¨ÙˆØ¯Ù†

def is_admin(update: Update, user_id): try: member = update.effective_chat.get_member(user_id) return member.status in [ChatMember.ADMINISTRATOR, ChatMember.CREATOR] except: return False

ÙØ±Ù…Ø§Ù† Ø¨Ù† (ÙØ§Ø±Ø³ÛŒ ÛŒØ§ Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ)

def ban_command(update: Update, context: CallbackContext): if not is_admin(update, update.effective_user.id): return if update.message.reply_to_message: user_id = update.message.reply_to_message.from_user.id ban_list.add(user_id) update.message.reply_text("Ú©Ø§Ø±Ø¨Ø± Ø¨Ù† Ø´Ø¯.") elif context.args: try: user_id = int(context.args[0]) ban_list.add(user_id) update.message.reply_text(f"Ú©Ø§Ø±Ø¨Ø± {user_id} Ø¨Ù† Ø´Ø¯.") except: update.message.reply_text("Ø¢ÛŒØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.")

Ø®ÙˆØ´â€ŒØ¢Ù…Ø¯Ú¯ÙˆÛŒÛŒ ØªØµÙˆÛŒØ±ÛŒ Ø³ÙØ§Ø±Ø´ÛŒ

def set_welcome_photo(update: Update, context: CallbackContext): if not is_admin(update, update.effective_user.id): return if update.message.reply_to_message and update.message.reply_to_message.photo: file_id = update.message.reply_to_message.photo[-1].file_id custom_welcome['photo'] = file_id update.message.reply_text("ğŸ“· Ø¹Ú©Ø³ Ø®ÙˆØ´â€ŒØ¢Ù…Ø¯Ú¯ÙˆÛŒÛŒ ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯.")

def set_welcome_text(update: Update, context: CallbackContext): if not is_admin(update, update.effective_user.id): return text = update.message.text.replace('Ù…ØªÙ† Ø®ÙˆØ´ Ø¢Ù…Ø¯', '').strip() custom_welcome['text'] = text update.message.reply_text("âœï¸ Ù…ØªÙ† Ø®ÙˆØ´â€ŒØ¢Ù…Ø¯Ú¯ÙˆÛŒÛŒ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯.")

def welcome_new_member(update: Update, context: CallbackContext): for member in update.message.new_chat_members: if custom_welcome['photo']: context.bot.send_photo( chat_id=update.effective_chat.id, photo=custom_welcome['photo'], caption=custom_welcome['text'] ) else: update.message.reply_text(custom_welcome['text'])

Ù¾ÛŒØ§Ù… Ø¯Ø± Ú¯ÙˆØ´ÛŒ (ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±Ø¨Ø± Ø®Ø§Øµ)

def secret_message(update: Update, context: CallbackContext): if update.message.reply_to_message: user_id = update.message.reply_to_message.from_user.id context.bot.send_message(chat_id=user_id, text=f"ğŸ“© Ù¾ÛŒØ§Ù… Ø¯Ø± Ú¯ÙˆØ´ÛŒ: {update.message.text.replace('Ù¾ÛŒØ§Ù… Ø¯Ø± Ú¯ÙˆØ´ÛŒ', '').strip()}") update.message.reply_text("âœ… Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.")

Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ø¨Ø±Ø§Ù†

def stats_scheduler(): message_count.clear()

def stats_handler(update: Update, context: CallbackContext): today = sum(message_count.values()) top_users = sorted(user_data.items(), key=lambda x: x[1]['count'], reverse=True) week_total = sum(u['count'] for u in user_data.values()) actives = sum(1 for u in user_data.values() if u['count'] > 0)

text = f"ğŸ“Š Ø¢Ù…Ø§Ø± Ø§Ù…Ø±ÙˆØ²: {today}\nğŸ—“ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ù‡ÙØªÙ‡: {week_total}\nğŸ‘¥ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙØ¹Ø§Ù„: {actives}\nğŸ† Ø±ØªØ¨Ù‡â€ŒÙ‡Ø§:\n"
for i, (user, data) in enumerate(top_users[:5], start=1):
    text += f"{i}. {user}: {data['count']} Ù¾ÛŒØ§Ù…\n"
update.message.reply_text(text)

Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ú©Ø§Ø±Ø¨Ø±

def profile(update: Update, context: CallbackContext): user = update.effective_user data = user_data[user.id] all_users = sorted(user_data.items(), key=lambda x: x[1]['count'], reverse=True) rank = next((i for i, (u, _) in enumerate(all_users, start=1) if u == user.id), '-') hours = ', '.join(str(h) for h in sorted(data['hours'])) text = f"ğŸ‘¤ Ù†Ø§Ù…: {user.full_name}\nğŸ“¨ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§: {data['count']}\nğŸ•’ Ø³Ø§Ø¹Ø§Øª ÙØ¹Ø§Ù„ÛŒØª: {hours}\nğŸ… Ø±ØªØ¨Ù‡: {rank}" update.message.reply_text(text)

Ø¢Ù…Ø§Ø±Ú¯ÛŒØ± Ø®ÙˆØ¯Ú©Ø§Ø±

scheduler = BackgroundScheduler() scheduler.add_job(stats_scheduler, 'cron', day_of_week='mon') scheduler.start()

Ø§ÙØ²Ø§ÛŒØ´ Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø¢Ù…Ø§Ø±

def message_counter(update: Update, context: CallbackContext): user_id = update.effective_user.id message_count[user_id] += 1 user_data[user_id]['count'] += 1 user_data[user_id]['hours'].add(datetime.datetime.now().hour)

Ø­Ø°Ù Ù„ÛŒÙ†Ú©â€ŒÙ‡Ø§ÛŒ Ø®Ø§Ù„ÛŒ ÛŒØ§ Ø¨ÛŒâ€ŒÙ…ÙˆØ±Ø¯

def is_supported_link(url): return any(domain in url for domain in ['youtube.com', 'youtu.be', 'instagram.com', 'tiktok.com', 'pinterest.com'])

def download_media(url, output_path): ydl_opts = { 'outtmpl': output_path, 'format': 'best[ext=mp4]/best', 'quiet': True, } try: with yt_dlp.YoutubeDL(ydl_opts) as ydl: info = ydl.extract_info(url, download=True) return ydl.prepare_filename(info) except Exception as e: return None

def handle_download(update: Update, context: CallbackContext): message = update.message if message.reply_to_message and message.text.lower().strip() == "Ø¯Ø§Ù†Ù„ÙˆØ¯": original_msg = message.reply_to_message link = None if original_msg.entities: for entity in original_msg.entities: if entity.type == MessageEntity.URL: link = original_msg.text[entity.offset:entity.offset + entity.length] break if not link and 'http' in original_msg.text: link = original_msg.text.split()[0]

if link:
        if is_supported_link(link):
            context.bot.send_chat_action(chat_id=message.chat_id, action="upload_video")
            message.reply_text("Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø§Ù†Ù„ÙˆØ¯ ... â³")
            file_path = download_media(link, f"{message.message_id}.%(ext)s")
            if file_path and os.path.exists(file_path):
                context.bot.send_document(chat_id=message.chat_id, document=open(file_path, 'rb'))
                os.remove(file_path)
                try:
                    context.bot.delete_message(chat_id=message.chat_id, message_id=original_msg.message_id)
                except:
                    pass
            else:
                message.reply_text("âš ï¸ Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙØ§ÛŒÙ„ Ù¾ÛŒØ´ Ø¢Ù…Ø¯.")
        else:
            message.reply_text("âŒ Ø§ÛŒÙ† Ù„ÛŒÙ†Ú© Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯.")
    else:
        try:
            context.bot.delete_message(chat_id=message.chat_id, message_id=original_msg.message_id)
        except:
            pass
        message.reply_text("âš ï¸ Ù„ÛŒÙ†Ú© Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª Ùˆ Ø­Ø°Ù Ø´Ø¯.")

def main(): updater = Updater("ØªÙˆÚ©Ù†_Ø±Ø¨Ø§Øª_Ø§ÛŒÙ†Ø¬Ø§", use_context=True) dp = updater.dispatcher

dp.add_handler(CommandHandler("start", lambda u, c: u.message.reply_text("Ø³Ù„Ø§Ù… Ù…Ù† Ø±Ø¨Ø§Øª ArmanLoyalGuy Ù‡Ø³ØªÙ…")))
dp.add_handler(CommandHandler(["Ø¨Ù†", "ban"], ban_command))
dp.add_handler(CommandHandler("Ø¢Ù…Ø§Ø±", stats_handler))
dp.add_handler(CommandHandler("Ù¾Ø±ÙˆÙØ§ÛŒÙ„", profile))
dp.add_handler(CommandHandler("ØªØ±Ø¬Ù…Ù‡", translate_reply))
dp.add_handler(CommandHandler("Ù¾ÛŒØ§Ù…_Ø¯Ø±_Ú¯ÙˆØ´ÛŒ", secret_message))
dp.add_handler(CommandHandler("Ø¹Ú©Ø³_Ø®ÙˆØ´_Ø¢Ù…Ø¯", set_welcome_photo))
dp.add_handler(CommandHandler("Ù…ØªÙ†_Ø®ÙˆØ´_Ø¢Ù…Ø¯", set_welcome_text))

dp.add_handler(MessageHandler(Filters.status_update.new_chat_members, welcome_new_member))
dp.add_handler(MessageHandler(Filters.text & Filters.reply, handle_download))
dp.add_handler(MessageHandler(Filters.text & (~Filters.command), message_counter))

updater.start_polling()
updater.idle()

if name == 'main': main()

